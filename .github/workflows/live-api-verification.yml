name: "Live API Verification"

# External Service Verification Tests (ESVTs)
#
# These tests hit REAL external APIs to verify our integration code works
# against actual API responses. They exist at the top of the test pyramid
# as deployment verification — catching contract drift, credential expiration,
# and parsing bugs that mocked tests cannot.
#
# Runs on: PRs targeting main (i.e., staging → main promotion)
#
# RULE: staging→main PRs MUST have all green lights including zero skips.
#       No test may be skipped — every connector must be fully operational.
#
# Cost tracking: A final job aggregates test results from ALL jobs and
# posts/updates a PR comment with per-test request counts, status, and
# estimated costs calculated from hardcoded per-API rates.
#
# Terminology (for searchability):
#   - Broad integration tests (Martin Fowler)
#   - Deployment Verification Tests (Jez Humble, Continuous Delivery)
#   - External Service Verification Tests (ESVTs)

on:
  pull_request:
    branches: [main]

permissions:
  pull-requests: write
  contents: read

jobs:
  # -----------------------------------------------------------------------
  # System-wide acceptance test — runs on EVERY staging→main PR regardless
  # of file changes. This is the cheapest possible "are all services alive?"
  # gate. Catches credential expiration and API outages that happen
  # independently of code changes.
  # -----------------------------------------------------------------------
  acceptance:
    name: "Acceptance: all connectors healthy"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v5
      - run: uv python install 3.12
      - run: uv sync

      - name: Run acceptance test (auth smoke across all connectors)
        env:
          UNIPILE_API_KEY: ${{ secrets.UNIPILE_API_KEY }}
          UNIPILE_DSN: ${{ secrets.UNIPILE_DSN }}
          X_BEARER_TOKEN: ${{ secrets.X_BEARER_TOKEN }}
          X_USERNAME: ${{ secrets.X_USERNAME }}
          POSTHOG_API_KEY: ${{ secrets.POSTHOG_API_KEY }}
          POSTHOG_PROJECT_ID: ${{ secrets.POSTHOG_PROJECT_ID }}
          RB2B_API_KEY: ${{ secrets.RB2B_API_KEY }}
        run: |
          uv run --package unlock-source-access pytest \
            packages/source-access/tests/test_live_api.py \
            -v -s -m "acceptance" --tb=short \
            2>&1 | tee acceptance-output.txt

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: acceptance-output
          path: acceptance-output.txt

  # -----------------------------------------------------------------------
  # Per-connector contract tests — on staging→main PRs, ALL connectors
  # are tested regardless of which files changed. This is the final gate
  # before production. No skips allowed.
  # -----------------------------------------------------------------------
  contract-unipile:
    name: "Contract: Unipile"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v5
      - run: uv python install 3.12
      - run: uv sync
      - name: Run Unipile contract tests
        env:
          UNIPILE_API_KEY: ${{ secrets.UNIPILE_API_KEY }}
          UNIPILE_DSN: ${{ secrets.UNIPILE_DSN }}
        run: |
          uv run --package unlock-source-access pytest \
            packages/source-access/tests/test_live_api.py \
            -v -s -m "contract" -k "Unipile" --tb=short \
            2>&1 | tee contract-unipile-output.txt
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: contract-unipile-output
          path: contract-unipile-output.txt

  contract-x:
    name: "Contract: X.com"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v5
      - run: uv python install 3.12
      - run: uv sync
      - name: Run X.com contract tests
        env:
          X_BEARER_TOKEN: ${{ secrets.X_BEARER_TOKEN }}
          X_USERNAME: ${{ secrets.X_USERNAME }}
        run: |
          uv run --package unlock-source-access pytest \
            packages/source-access/tests/test_live_api.py \
            -v -s -m "contract" -k "XContract" --tb=short \
            2>&1 | tee contract-x-output.txt
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: contract-x-output
          path: contract-x-output.txt

  contract-posthog:
    name: "Contract: PostHog"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v5
      - run: uv python install 3.12
      - run: uv sync
      - name: Run PostHog contract tests
        env:
          POSTHOG_API_KEY: ${{ secrets.POSTHOG_API_KEY }}
          POSTHOG_PROJECT_ID: ${{ secrets.POSTHOG_PROJECT_ID }}
        run: |
          uv run --package unlock-source-access pytest \
            packages/source-access/tests/test_live_api.py \
            -v -s -m "contract" -k "PostHog" --tb=short \
            2>&1 | tee contract-posthog-output.txt
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: contract-posthog-output
          path: contract-posthog-output.txt

  contract-rb2b:
    name: "Contract: RB2B"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v5
      - run: uv python install 3.12
      - run: uv sync
      - name: Run RB2B contract tests
        env:
          RB2B_API_KEY: ${{ secrets.RB2B_API_KEY }}
        run: |
          uv run --package unlock-source-access pytest \
            packages/source-access/tests/test_live_api.py \
            -v -s -m "contract" -k "RB2B" --tb=short \
            2>&1 | tee contract-rb2b-output.txt
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: contract-rb2b-output
          path: contract-rb2b-output.txt

  # -----------------------------------------------------------------------
  # Cost report — aggregates results from ALL jobs and posts a single
  # auto-updating PR comment with per-test breakdown, status, and costs.
  #
  # Cost rates are hardcoded here. Update them when API pricing changes.
  # -----------------------------------------------------------------------
  cost-report:
    name: "Cost Report"
    needs: [acceptance, contract-unipile, contract-x, contract-posthog, contract-rb2b]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v4
        with:
          merge-multiple: true

      - name: Build cost report
        env:
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          RUN_NUMBER: ${{ github.run_number }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          python3 << 'PYEOF'
          import glob, os, re

          # -----------------------------------------------------------------
          # Cost rates per API request — UPDATE THESE when pricing changes
          # -----------------------------------------------------------------
          COST_RATES = {
              "unipile":         0.00,   # subscription-based
              "x":               0.01,   # Basic tier ~$100/month for 10K reads
              "posthog":         0.00,   # free API tier
              "rb2b_free":       0.00,   # GET /credits is free
              "rb2b_enrichment": 0.09,   # $9 per 100 credits, 1 credit per call
          }

          def classify_api(label):
              low = label.lower()
              if "unipile" in low:
                  return "unipile"
              if "x.com" in low or low.startswith("x "):
                  return "x"
              if "posthog" in low:
                  return "posthog"
              if "rb2b" in low:
                  if "smoke" in low or "acceptance" in low:
                      return "rb2b_free"
                  return "rb2b_enrichment"
              return "unipile"

          dollar = "$"
          rows = []
          test_statuses = {}

          for path in sorted(glob.glob("*-output.txt")):
              job = os.path.basename(path).replace("-output.txt", "").replace("-", " ").title()
              lines = open(path).readlines()

              # Collect test statuses: track current test, match standalone PASSED/FAILED
              current_test = None
              for line in lines:
                  # Test path line: "packages/.../test_live_api.py::TestClass::test_method"
                  tm = re.search(r"::(\S+::\S+)", line)
                  if tm:
                      current_test = tm.group(1)
                  # Standalone status line (pytest -v -s puts PASSED on its own line)
                  sm = re.match(r"^(PASSED|FAILED|SKIPPED)", line.strip())
                  if sm and current_test:
                      test_statuses[current_test] = sm.group(1)
                      current_test = None
                  # Same-line status (no stdout captured)
                  sm2 = re.search(r"::(\S+::\S+)\s+(PASSED|FAILED|SKIPPED)", line)
                  if sm2:
                      test_statuses[sm2.group(1)] = sm2.group(2)

              # Collect request counts and pair with nearby test status
              for i, line in enumerate(lines):
                  m = re.search(r"\[(.+?)\] API requests: (\d+)", line)
                  if not m:
                      continue
                  label, count = m.group(1), int(m.group(2))
                  rate_key = classify_api(label)
                  cost = count * COST_RATES[rate_key]

                  # Find nearest PASSED/FAILED/SKIPPED after this line
                  status_str = ""
                  for j in range(i + 1, min(i + 15, len(lines))):
                      sm = re.match(r"^(PASSED|FAILED|SKIPPED)", lines[j].strip())
                      if sm:
                          s = sm.group(1)
                          icon = {"PASSED": "✅", "FAILED": "❌", "SKIPPED": "⏭️"}[s]
                          status_str = icon + " " + s
                          break
                      if "API requests:" in lines[j]:
                          break

                  rows.append((job, label, count, status_str or "—", cost))

          total_requests = sum(r[2] for r in rows)
          total_cost = sum(r[4] for r in rows)
          passed = sum(1 for s in test_statuses.values() if s == "PASSED")
          failed = sum(1 for s in test_statuses.values() if s == "FAILED")
          skipped = sum(1 for s in test_statuses.values() if s == "SKIPPED")
          total_tests = len(test_statuses)

          head = os.environ.get("HEAD_SHA", "unknown")
          run_num = os.environ.get("RUN_NUMBER", "?")
          run_url = os.environ.get("RUN_URL", "#")

          md = []
          md.append("## Live API Verification — Cost Report\n")
          md.append("**Commit:** `%s` | **Run:** [#%s](%s)\n" % (head, run_num, run_url))
          md.append("### Test Results\n")
          md.append("| Job | Test | Requests | Status | Est. Cost |")
          md.append("|-----|------|----------|--------|-----------|")
          for job, label, reqs, status, cost in rows:
              md.append("| %s | %s | %d | %s | %s%.2f |" % (job, label, reqs, status, dollar, cost))

          md.append("")
          md.append("### Summary\n")
          md.append("| Metric | Value |")
          md.append("|--------|-------|")
          md.append("| Total tests | %d |" % total_tests)
          md.append("| Passed | %d |" % passed)
          md.append("| Failed | %d |" % failed)
          md.append("| Skipped | %d |" % skipped)
          md.append("| Total API requests | %d |" % total_requests)
          md.append("| **Estimated cost this run** | **%s%.2f** |" % (dollar, total_cost))

          md.append("")
          md.append("<details><summary>Cost rates (update when API pricing changes)</summary>\n")
          md.append("| API | Rate | Notes |")
          md.append("|-----|------|-------|")
          md.append("| Unipile | %s0.00/req | Subscription-based |" % dollar)
          md.append("| X.com | %s0.01/req | Basic tier (~%s100/10K reads) |" % (dollar, dollar))
          md.append("| PostHog | %s0.00/req | Free API tier |" % dollar)
          md.append("| RB2B (credits check) | %s0.00 | GET /credits is free |" % dollar)
          md.append("| RB2B (enrichment) | %s0.09/credit | %s9 per 100 credits |" % (dollar, dollar))
          md.append("\n</details>")

          report = "\n".join(md)
          print(report)
          with open("cost-report.md", "w") as f:
              f.write(report)
          PYEOF

      - name: Post cost report as PR comment
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          COMMENT_TAG="<!-- live-api-cost-report -->"
          PR_NUMBER=${{ github.event.pull_request.number }}

          echo "$COMMENT_TAG" > comment-body.md
          cat cost-report.md >> comment-body.md
          echo "" >> comment-body.md
          echo "---" >> comment-body.md
          echo "*Updated: $(date -u '+%Y-%m-%d %H:%M UTC')*" >> comment-body.md

          # Find existing cost report comment or create new one
          EXISTING_COMMENT_ID=$(gh api \
            "repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
            --jq ".[] | select(.body | startswith(\"$COMMENT_TAG\")) | .id" \
            2>/dev/null | head -1)

          if [ -n "$EXISTING_COMMENT_ID" ]; then
            gh api \
              "repos/${{ github.repository }}/issues/comments/${EXISTING_COMMENT_ID}" \
              -X PATCH \
              -f body="$(cat comment-body.md)"
            echo "Updated existing cost report comment #${EXISTING_COMMENT_ID}"
          else
            gh api \
              "repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
              -f body="$(cat comment-body.md)"
            echo "Created new cost report comment"
          fi
